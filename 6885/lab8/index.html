<html>
<head>
<title>Daniel Smilkov, 6.885 Lab 8, Detecting significant events</title>
<link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css" />
<script src="http://code.jquery.com/jquery-1.9.1.js"></script>
<script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<style>
.axis path, .axis line {
   fill: none;
   stroke: #000;
   shape-rendering: crispEdges;
}

.line {
  fill: none;
  stroke: black;
  stroke-width: 1.5px;
}

body {
	font-size: 14px;
	font-family: sans-serif;
}

#high, #low {
	stroke:red;
}

#slider {
	width:200px;
}

#reading_msg {
}

#analyzing_msg {
	display: none;
}

</style>
</head>
<body>
<h2>Detecting significant events around points of Interest</h2>
<p>Answers to some questions:</p>
<p><b>What is the message in your visualization and what techniques did you use to illustrate it?</b><p>
	<ul><li>This line plot shows the number of taxi pickups <u>in a given day</u>, <u>in a given radius</u> around a <u>point of interest</u> over the total number of taxi pickups for that day. Assuming each pickup is independent from other pickups in a given day, this fraction is <a href="http://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval">Binomial proportion</a>. Thus, we can compute confidence intervals and look for days where this fraction has significant change, pointing to significant events. The dotted red lines show the 95% confidence intervals computed using the <a href="http://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Wilson_score_interval">Wilson score interval</a>.</li></ul>
<p><b>If you used interaction or animation, how does it facilitate the user's understanding?</b></p>
	<ul><li>The user can change the radius and directly observe the reconstructed visualization. This helps because the radius that works best is different for different points of interests.</li></ul>
<p><b>What format is the data that is used by the visualization? Is it the raw data or did you need to compute some summary or derived data product?</b></p>
	<ul><li>There is a minimal pre-processing in python, where the data is subsampled to 1 million points.</li></ul>

<h3 id="reading_msg">Reading points...</h3>
<h3 id="analyzing_msg"></h3>


<p>The user can change the radius and the point of interest. The y axis is not fixed and gets rescaled every time a parameter is changed, since we are not interested in the actual numbers but a significant change between two numbers. Here are two observations to get you started:</p>
<ul>
<li>Paul Mccartney concert, Fenway Way, July 9, 2013. <a href="#" onclick="event1();">Click here to see</a>.</li>
<li>Independence day, USS Constitution, July 4, 2013. <a href="#" onclick="event2();">Click here to see</a>.</li>
</ul>

<select style="margin-bottom:10px;" id="options"></select>
<div id="slider"></div> <p>Radius: <b><span id="radius">0.5</span></b> km.</p>

</body>
<script>

function event1() {
	$('#slider').slider("option", "value", 0.2);
	$( "#options" ).val(19);
	compute();
}

function event2() {
	$('#slider').slider("option", "value", 0.3);
	$( "#options" ).val(4);
	compute();
}

$(function() {
    $( "#slider" ).slider({
    	min: 0,
    	max: 1.0,
    	step: 0.05,
    	value:0.5,
    	slide: function( event, ui ) {
    		$('span#radius').html(ui.value);
    		$('#slider').slider("option", "value", ui.value);
    		compute();
    	},

    	change: function(event, ui) {
    		$('span#radius').html(ui.value);
    	}
    });
});

Date.prototype.getWeek = function() {
        var onejan = new Date(this.getFullYear(),0,1);
        return Math.ceil((((this - onejan) / 86400000) + onejan.getDay()+1)/7);
} 

Date.prototype.getDayOfYear = function() {
	var yn = this.getFullYear();
	var mn = this.getMonth();
	var dn = this.getDate();
	var d1 = new Date(yn,0,1,12,0,0); // noon on Jan. 1
	var d2 = new Date(yn,mn,dn,12,0,0); // noon on input date
	var ddiff = Math.round((d2-d1)/864e5);
	return ddiff;
}

function wilsonScoreInterval(pos, n) {
  if (n === 0) return 0;
  var phat = pos / n;
  z = 1.96; //1.96 is 95% confidence, 2.576 is 99% confidence
  return [(phat + z*z/(2*n) - z * Math.sqrt((phat*(1-phat)+z*z/(4*n))/n))/(1+z*z/n), (phat + z*z/(2*n) + z * Math.sqrt((phat*(1-phat)+z*z/(4*n))/n))/(1+z*z/n)];
}

function distance(lat1, long1, lat2, long2) {
    // Convert latitude and longitude to spherical coordinates in radians.
    degrees_to_radians = Math.PI/180.0
        
    // phi = 90 - latitude
    phi1 = (90.0 - lat1)*degrees_to_radians
    phi2 = (90.0 - lat2)*degrees_to_radians
        
    // theta = longitude
    theta1 = long1*degrees_to_radians
    theta2 = long2*degrees_to_radians
        
    // Compute spherical distance from spherical coordinates.
        
    // For two locations in spherical coordinates 
    // (1, theta, phi) and (1, theta, phi)
    // cosine( arc length ) = 
    //    sin phi sin phi' cos(theta-theta') + cos phi cos phi'
    // distance = rho * arc length
    
    cos = (Math.sin(phi1)*Math.sin(phi2)*Math.cos(theta1 - theta2) + Math.cos(phi1)*Math.cos(phi2));
    arc = Math.acos( cos );

    // Remember to multiply arc by the radius of the earth 
    // in your favorite set of units to get length.
    return arc * 6371.0
}

function visualize(data) {
	var margin = {top: 20, right: 20, bottom: 30, left: 20}, width = 900 - margin.left - margin.right, height = 200 - margin.top - margin.bottom;

	// a scale for the x axis
	var x = d3.scale.linear()
    	.range([0, width])
    	.domain(d3.extent(Object.keys(pickupsPerDay)));
    
    // a time scale for the x axis
    var start = new Date()
    var xTime = d3.time.scale()
    	.range([0, width])
    	.domain([new Date(minDate), new Date(maxDate)]); //TODO
    
    var xAxis = d3.svg.axis()
    	.scale(xTime)
    	.orient("bottom")
    	.ticks(d3.time.week, 2);

	// a scale for the y axis
	var y = d3.scale.linear()
    	.range([height, 0])
    	.domain([d3.min(data, function(d) { return d.mid; }),d3.max(data, function(d) { return d.mid; })]);

    var lineMid = d3.svg.line().interpolate("basis")
    	.x(function(d) { return x(d.day); })
    	.y(function(d) { return y(d.mid); });

    var lineHigh = d3.svg.line().interpolate("basis")
    	.x(function(d) { return x(d.day); })
    	.y(function(d) { return y(d.high); });

    var lineLow = d3.svg.line().interpolate("basis")
    	.x(function(d) { return x(d.day); })
    	.y(function(d) { return y(d.low); });

	// the main svg
	var svg = d3.select('svg');
	if (svg[0][0] === null) {
		svg = d3.select("body").append("svg")
		.attr("width", width + margin.left + margin.right)
    	.attr("height", height + margin.top + margin.bottom)
  		.append("g")
    	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");	
	}
	var xAxisElem = d3.select("#xaxis");
	if(xAxisElem[0][0] === null) {
		svg.append("g")
	      .attr("class", "x axis")
	      .attr("id", "xaxis")
	      .attr("transform", "translate(0," + height + ")")
	      .call(xAxis);
	}

    var midPath = svg.select("#mid");
    var lowPath = svg.select("#low");
    var highPath = svg.select("#high");
    if(midPath[0][0] === null) {
    	midPath = svg.append("path").attr("class", "line").attr("id", 'mid');
    	lowPath = svg.append("path").attr("class", "line").attr("id", 'low').style("stroke-dasharray", ("3, 3"))
    	highPath = svg.append("path").attr("class", "line").attr("id", 'high').style("stroke-dasharray", ("3, 3"))
    }
    midPath.datum(data).transition().attr("d", lineMid);
    lowPath.datum(data).transition().attr("d", lineLow);
    highPath.datum(data).transition().attr("d", lineHigh);
}

function compute() {
	var radiusKM = $('#slider').slider("option", "value");
	var interestIdx = $( "#options" ).val();
	// get the conditional probability
	var interestPoint = interestpoints[interestIdx];
	var localPickupsPerDay = {};

	for(var i=0; i < pickups.length; i++) {
		if(interestPickupDistance[interestIdx][i] < radiusKM) {
			if (!(pickups[i][0] in localPickupsPerDay)) {
				localPickupsPerDay[pickups[i][0]] = 0;
			}
			localPickupsPerDay[pickups[i][0]]+=1;
		}
	}
	var data = [];
 	for (var day in pickupsPerDay) {
 		if (!(day in localPickupsPerDay)) {
				localPickupsPerDay[day] = 0;
		}
 		var value = localPickupsPerDay[day];
		var tmp = wilsonScoreInterval(value, pickupsPerDay[day]);
		var low = tmp[0];
		var high = tmp[1];
		var mid = value / pickupsPerDay[day];
		data.push({day: day, low: low, high: high, mid: mid });
	}
	visualize(data);
}

var pickups;
var interestpoints;
var pickupsPerDay;
var interestPickupDistance = {};
var minDate = new Date();
var maxDate = 0;
d3.json("pickups_small.json", function(error, json) {
	pickups = json.slice(0,1000000);
	pickupsPerDay = {};
	console.log(pickups.length + " total number of points");
	$('#reading_msg').hide();
	$("#analyzing_msg").html('Analyzing ' + pickups.length + ' points. It may take up to a minute...');
	$("#analyzing_msg").show();
	d3.json("interestpoints.json", function(error, json) {
		interestpoints = json;
		//populate the select drop-down menu
		var options = $("#options");
		$.each(interestpoints, function(index, interestPoint) {
		    options.append($("<option />").val(index).text(interestPoint[0]));
		});
		options.change(function(eventData) { compute();});

		// get the minimum and the max date
		for(var i=0; i < pickups.length; i++) {
			var date = new Date(pickups[i][0]*1000);
			pickups[i][0] = date.getDayOfYear();
			minDate = Math.min(minDate, date);
			maxDate = Math.max(maxDate, date);
			if (!(pickups[i][0] in pickupsPerDay)) {
				pickupsPerDay[pickups[i][0]] = 0;
			}
			pickupsPerDay[pickups[i][0]] += 1;
		}

		// pre-compute the distance between all the points and the interest points
		for(var i=0;i<interestpoints.length;i++) {
			interestPickupDistance[i] = new Array(pickups.length);
			for(var j=0;j<pickups.length;j++) {
				interestPickupDistance[i][j] = distance(interestpoints[i][1], interestpoints[i][2], pickups[j][1], pickups[j][2]);
			}
		}
		compute();
		$("#analyzing_msg").hide();
	});
});

</script>
</html>